const test = require('node:test');
const assert = require('node:assert');
const { createRoom, server } = require('../src/app.js');

test('createRoom creates a room with a code', (t) => {
  const room = createRoom({ description: 'test context' }, 'test prompt');
  assert.strictEqual(typeof room.code, 'string');
  assert.strictEqual(room.code.length, 5);
  assert.strictEqual(room.context, 'test context');
  assert.strictEqual(room.prompt, 'test prompt');
});

test('POST /world/autocomplete should return a world object', async (t) => {
    // Mock the global fetch
    const originalFetch = global.fetch;
    global.fetch = async (url, options) => {
        // We expect a JSON response from the AI service, wrapped in the provider's format
        return {
            ok: true,
            json: async () => ({
                choices: [{
                    message: {
                        content: JSON.stringify({
                            "name": "Generated World",
                            "description": "A world generated by AI.",
                            "genre": "Fantasy",
                            "artStyle": "Pixel Art",
                            "gameMechanics": "Dice rolls and role-playing.",
                            "winLossConditions": "Complete the main quest to win."
                        })
                    }
                }]
            })
        };
    };

    // Need to import `app` to make requests to it
    const { app } = require('../src/app.js');
    const request = require('supertest');

    const response = await request(app)
        .post('/world/autocomplete')
        .send({
            world: {
                description: "A world for testing"
            },
            ai_settings: {
                provider: 'openai',
                apiKey: 'test-key'
            }
        });

    assert.strictEqual(response.status, 200);
    assert.deepStrictEqual(response.body, {
        "name": "Generated World",
        "description": "A world generated by AI.",
        "genre": "Fantasy",
        "artStyle": "Pixel Art",
        "gameMechanics": "Dice rolls and role-playing.",
        "winLossConditions": "Complete the main quest to win."
    });

    // Restore original fetch
    global.fetch = originalFetch;
});

test('POST /world/image should return 500 if OPENAI_API_KEY is not set', async (t) => {
    const { app } = require('../src/app.js');
    const request = require('supertest');

    const response = await request(app)
        .post('/world/image')
        .send({
            description: "A world for testing",
            artStyle: "Pixel Art"
        });

    assert.strictEqual(response.status, 500);
    assert.deepStrictEqual(response.body, {
        detail: 'The person who deployed this app has not set the OPENAI_API_KEY environment variable.'
    });
});

test('POST /world/autocomplete should return 500 if api key is missing', async (t) => {
    const { app } = require('../src/app.js');
    const request = require('supertest');

    const response = await request(app)
        .post('/world/autocomplete')
        .send({
            world: {
                description: "A world for testing"
            },
            ai_settings: {
                provider: 'openai',
                apiKey: ''
            }
        });

    assert.strictEqual(response.status, 500);
    assert.deepStrictEqual(response.body, {
        detail: 'An error occurred during auto-complete.',
        error: 'Missing API key for selected provider.'
    });
});

test('POST /room/:code/player/:playerId/regenerate-image should regenerate an image', async (t) => {
    const { app, rooms, createRoom } = require('../src/app.js');
    const request = require('supertest');

    // 1. Setup
    const room = createRoom({ description: 'test world', artStyle: 'test style' }, 'test prompt');
    const playerId = 'testplayer';
    const player = {
        id: playerId,
        name: 'Test Player',
        character: {
            race: 'Human',
            imageUrl: 'initial_url',
        },
        regenerationAttempts: 0,
    };
    room.players.set(playerId, player);
    rooms.set(room.code, room);

    // Mock fetch
    const originalFetch = global.fetch;
    let fetchCallCount = 0;
    global.fetch = async (url, options) => {
        fetchCallCount++;
        return {
            ok: true,
            json: async () => ({
                data: [{ url: `new_image_url_${fetchCallCount}` }]
            })
        };
    };

    // 2. First regeneration
    let response = await request(app)
        .post(`/room/${room.code}/player/${playerId}/regenerate-image`);

    assert.strictEqual(response.status, 200);
    assert.strictEqual(response.body.character.imageUrl, 'new_image_url_1');
    assert.strictEqual(response.body.regenerationAttempts, 1);
    assert.strictEqual(room.players.get(playerId).character.imageUrl, 'new_image_url_1');
    assert.strictEqual(room.players.get(playerId).regenerationAttempts, 1);

    // 3. Second and third regenerations
    await request(app).post(`/room/${room.code}/player/${playerId}/regenerate-image`);
    await request(app).post(`/room/${room.code}/player/${playerId}/regenerate-image`);

    assert.strictEqual(room.players.get(playerId).regenerationAttempts, 3);
    assert.strictEqual(room.players.get(playerId).character.imageUrl, 'new_image_url_3');


    // 4. Fourth regeneration should fail
    response = await request(app)
        .post(`/room/${room.code}/player/${playerId}/regenerate-image`);

    assert.strictEqual(response.status, 400);
    assert.deepStrictEqual(response.body, {
        detail: 'You have reached the maximum number of regeneration attempts.'
    });

    // Restore original fetch
    global.fetch = originalFetch;
});

// Make sure to close the server after all tests
test.after(() => server.close());
