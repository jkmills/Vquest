<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>DM Screen</title>
  <link rel="stylesheet" href="medieval.css">
  <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
  <script src="https://cdn.jsdelivr.net/npm/qrcode@1.5.1/build/qrcode.min.js"></script>
</head>
<body>
  <div id="root" style="max-width: 500px; margin: 2em auto; background: #fffbe6cc; border-radius: 16px; box-shadow: 2px 2px 12px #0003; padding: 2em;"></div>
  <script>

    // World management
    const WORLDS_KEY = 'vquest_worlds';
    function getWorlds() {
      const raw = localStorage.getItem(WORLDS_KEY);
      if (raw) return JSON.parse(raw);
      // Default worlds
      return [
        { name: 'Dragon\'s Peak', description: 'A dragon has been terrorizing the kingdom. The party must track it to its lair and defeat it.' },
        { name: 'The Sunken City', description: 'A legendary artifact has gone missing from the royal vault. The party must recover it before it falls into the wrong hands.' },
        { name: 'Whispering Woods', description: 'Villagers report strange happenings in the nearby forest. The party must investigate and lift the curse.' }
      ];
    }
    function saveWorlds(ws) { localStorage.setItem(WORLDS_KEY, JSON.stringify(ws)); }

    // AI settings management
    const AI_SETTINGS_KEY = 'vquest_ai_settings';
    function getAiSettings() {
      const raw = localStorage.getItem(AI_SETTINGS_KEY);
      if (raw) return JSON.parse(raw);
      return { provider: 'openai', apiKey: '' };
    }
    function saveAiSettings(s) { localStorage.setItem(AI_SETTINGS_KEY, JSON.stringify(s)); }


    function App() {
      const [roomCode, setRoomCode] = React.useState(null);
      const [worlds, setWorlds] = React.useState(getWorlds());
      const [aiSettings, setAiSettings] = React.useState(getAiSettings());
      const [selectedWorld, setSelectedWorld] = React.useState(worlds[0]?.name || '');
      const [showSettings, setShowSettings] = React.useState(false);
      const [editWorld, setEditWorld] = React.useState(null);
      const wsRef = React.useRef(null);

      const [context, setContext] = React.useState('');
      const [prompt, setPrompt] = React.useState('');
      const [actions, setActions] = React.useState([]);
      const [votes, setVotes] = React.useState([]);
      const [players, setPlayers] = React.useState({});
      const [phase, setPhase] = React.useState('SUBMITTING');
      const [winningAction, setWinningAction] = React.useState(null);
      const [worldImage, setWorldImage] = React.useState(null);
      const [isGeneratingImage, setIsGeneratingImage] = React.useState(false);

      // Create room with selected world description
      const createRoom = async () => {
        const worldObj = worlds.find(w => w.name === selectedWorld);
        const res = await fetch('/room', {
          method: 'POST',
          headers: {'Content-Type': 'application/json'},
          body: JSON.stringify({
            world: worldObj,
            prompt: worldObj?.prompt || 'The adventure begins! What will you do first?',
            ai_settings: aiSettings
          })
        });
        const data = await res.json();
        setRoomCode(data.code);
        setContext(worldObj?.description || '');
        setPrompt(worldObj?.prompt || 'The adventure begins! What will you do first?');
      };

      const generateImage = async () => {
        setIsGeneratingImage(true);
        const worldObj = worlds.find(w => w.name === selectedWorld);
        try {
          const res = await fetch('/world/image', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({
              description: worldObj?.description || '',
              artStyle: worldObj?.artStyle || ''
            })
          });
          if (!res.ok) {
            const err = await res.json();
            alert(`Error generating image: ${err.detail || 'Unknown error'}`);
            return;
          }
          const data = await res.json();
          setWorldImage(data.imageUrl);
        } catch (error) {
          console.error("Image generation request failed", error);
          alert('An unexpected error occurred during image generation.');
        } finally {
          setIsGeneratingImage(false);
        }
      };

      const nextStep = async () => {
        await fetch(`/room/${roomCode}/next`, {
          method: 'POST'
        });
      };

      React.useEffect(() => {
        if (!roomCode) return;
        const wsProto = location.protocol === 'https:' ? 'wss' : 'ws';
        const ws = new WebSocket(`${wsProto}://${location.host}/room/${roomCode}`);
        ws.onmessage = (e) => {
          try {
            const data = JSON.parse(e.data);
            if (data.context) setContext(data.context);
            if (data.prompt) setPrompt(data.prompt);
            if (data.phase) setPhase(data.phase);
            if (data.actions) setActions(data.actions);
            if (data.votes) setVotes(data.votes);
            if (data.players) setPlayers(data.players);
            if (data.winningAction) setWinningAction(data.winningAction);

            // When the game resets, clear the old round's data
            if (data.phase === 'SUBMITTING') {
                setActions([]);
                setVotes([]);
                setWinningAction(null);
            }
          } catch (error) {
            console.error('Error parsing WebSocket message:', error);
          }
        };
        wsRef.current = ws;
        return () => ws.close();
      }, [roomCode]);

      React.useEffect(() => {
        if (!roomCode) return;
        // Point QR to the player view so scanners land on the join form
        const joinUrl = `${location.origin}/player.html?code=${roomCode}`;
        const qrEl = document.getElementById('qr');
        qrEl.innerHTML = '';
        QRCode.toCanvas(joinUrl, { width: 200 }, (err, canvas) => {
          if (err) return console.error(err);
          qrEl.appendChild(canvas);
        });
      }, [roomCode]);

      // Settings modal logic
      function openSettings() {
        setEditWorld(null);
        setShowSettings(true);
      }
      function closeSettings() { setShowSettings(false); }
      function startEdit(w) { setEditWorld(w); setShowSettings(true); }
      function saveWorld(w) {
        let newWorlds = worlds.slice();
        if (editWorld) {
          newWorlds = newWorlds.map(x => x.name === editWorld.name ? w : x);
        } else {
          newWorlds.push(w);
        }
        setWorlds(newWorlds);
        saveWorlds(newWorlds);
        setEditWorld(null);
        setShowSettings(false);
      }
      function handleAiSettingsChange(newSettings) {
        setAiSettings(newSettings);
        saveAiSettings(newSettings);
      }
      function deleteWorld(w) {
        const newWorlds = worlds.filter(x => x.name !== w.name);
        setWorlds(newWorlds);
        saveWorlds(newWorlds);
        setEditWorld(null);
        setShowSettings(false);
        if (selectedWorld === w.name && newWorlds.length) setSelectedWorld(newWorlds[0].name);
      }

      const [creationStep, setCreationStep] = React.useState('start');

      // World description for current selection
      const worldObj = worlds.find(w => w.name === selectedWorld);

      const mainContent = () => {
        if (showSettings) {
          return React.createElement(SettingsModal, {
            worlds, editWorld, aiSettings,
            onClose: closeSettings,
            onEdit: startEdit,
            onSave: saveWorld,
            onDelete: deleteWorld,
            onAiSettingsChange: handleAiSettingsChange
          });
        }
        if (roomCode) {
          return React.createElement('div', null,
            React.createElement('h2', null, `Room ${roomCode}`),
            React.createElement('p', null, `Current Phase: `, React.createElement('b', null, phase)),
            phase === 'POST_VOTE' && React.createElement('button', {onClick: nextStep, style: {fontSize: '1.2em', padding: '0.7em 2em'}}, 'Start Next Round'),
            React.createElement('a', {href: `${location.origin}/player.html?code=${roomCode}`, target: '_blank'},
              React.createElement('div', {id: 'qr'})
            ),
            React.createElement('h3', null, 'Players'),
            Object.values(players).map(p => React.createElement('div', {key: p.id},
              React.createElement('h4', null, p.name),
              React.createElement('ul', null,
                Object.entries(p.character.stats).map(([stat, value]) =>
                  React.createElement('li', {key: stat}, `${stat}: ${value}`)
                )
              ),
              React.createElement('h5', null, 'Inventory'),
              React.createElement('ul', null,
                p.character.inventory.length > 0
                  ? p.character.inventory.map((item, i) =>
                      React.createElement('li', {key: i}, item)
                    )
                  : React.createElement('li', null, 'Empty')
              )
            )),
            React.createElement('h3', null, 'Story'),
            React.createElement('div', {style: {whiteSpace: 'pre-wrap', marginBottom: '1em', fontStyle: 'italic', background: '#f4e1b6', padding: '0.7em', borderRadius: '8px'}}, context),
            React.createElement('h3', null, 'Prompt'),
            React.createElement('div', {style: {marginBottom: '1em', fontWeight: 'bold'}}, prompt),
            React.createElement('h3', null, 'Player Actions'),
            actions.map((action, i) =>
              React.createElement('div', {key: i, style: {marginBottom: '0.5em'}},
                `* ${action.text} (${votes[i] || 0} votes)`
              )
            ),
            winningAction && React.createElement('div', {style: {marginTop: '1em', fontWeight: 'bold', color: 'green'}},
              `Winning Action: ${winningAction.text}`
            )
          );
        }
        switch (creationStep) {
          case 'start':
            return React.createElement('div', null,
              React.createElement('div', {style: {marginBottom: '1em'}},
                React.createElement('label', {htmlFor: 'worldSel', style: {fontWeight: 'bold'}}, 'World: '),
                React.createElement('select', {
                  id: 'worldSel', value: selectedWorld,
                  onChange: e => setSelectedWorld(e.target.value),
                  style: {fontSize: '1em', marginRight: '1em'}
                },
                  worlds.map(w => React.createElement('option', {key: w.name, value: w.name}, w.name))
                ),
                React.createElement('button', {onClick: openSettings, style: {float: 'right'}}, '⚙️ Settings')
              ),
              worldObj && React.createElement('div', {style: {marginBottom: '1em', fontStyle: 'italic', background: '#f4e1b6', padding: '0.7em', borderRadius: '8px'}}, worldObj.description),
              React.createElement('div', {style: {marginTop: '1em', textAlign: 'center'}},
                React.createElement('button', {onClick: () => setCreationStep('details'), style: {fontSize: '1.2em', padding: '0.7em 2em'}}, 'Create New World')
              )
            );
          case 'details':
            return React.createElement(WorldDetailsEditor, {
              aiSettings,
              onSave: (w) => {
                saveWorld(w);
                setSelectedWorld(w.name);
                setCreationStep('image');
              },
              onCancel: () => setCreationStep('start')
            });
          case 'image':
            return React.createElement('div', null,
              React.createElement('h2', null, 'World Image'),
              worldObj && React.createElement('div', {style: {marginBottom: '1em', fontStyle: 'italic', background: '#f4e1b6', padding: '0.7em', borderRadius: '8px'}}, worldObj.description),

              isGeneratingImage && React.createElement('div', {style: {margin: '1em 0', textAlign: 'center'}},
                React.createElement('p', null, 'Generating image, please wait...')
              ),

              !isGeneratingImage && worldImage && React.createElement('img', {src: worldImage, style: {maxWidth: '100%', borderRadius: '8px', marginTop: '1em'}}),

              React.createElement('div', {style: {marginTop: '1em', textAlign: 'center'}},
                React.createElement('button', {
                  onClick: generateImage,
                  disabled: isGeneratingImage,
                  style: {fontSize: '1em', padding: '0.5em 1em', marginRight: '1em'}
                }, isGeneratingImage ? 'Generating...' : 'Generate Image'),

                worldImage && !isGeneratingImage
                  ? React.createElement('button', {
                      onClick: () => setCreationStep('done'),
                      style: {fontSize: '1em', padding: '0.5em 1em'}
                    }, 'Accept Image')
                  : React.createElement('button', {
                      onClick: () => setCreationStep('done'),
                      disabled: isGeneratingImage,
                      style: {fontSize: '1em', padding: '0.5em 1em'}
                    }, 'Skip')
              )
            );
          case 'done':
            return React.createElement('div', null,
              React.createElement('h2', null, 'Ready to Play'),
              worldObj && React.createElement('div', {style: {marginBottom: '1em', fontStyle: 'italic', background: '#f4e1b6', padding: '0.7em', borderRadius: '8px'}}, worldObj.description),
              worldImage && React.createElement('img', {src: worldImage, style: {maxWidth: '100%', borderRadius: '8px'}}),
              React.createElement('div', {style: {marginTop: '1em', textAlign: 'center'}},
                React.createElement('button', {onClick: createRoom, style: {fontSize: '1.2em', padding: '0.7em 2em'}}, 'Create Game World')
              )
            );
          default:
            return React.createElement('div', null, 'Something went wrong.');
        }
      };

      return React.createElement('div', null,
        React.createElement('h1', null, 'DM Screen'),
        mainContent()
      );
    }

    function WorldDetailsEditor({ aiSettings, onSave, onCancel, editWorld }) {
      const [name, setName] = React.useState(editWorld ? editWorld.name : '');
      const [description, setDescription] = React.useState(editWorld ? editWorld.description : '');
      const [genre, setGenre] = React.useState(editWorld ? editWorld.genre : '');
      const [artStyle, setArtStyle] = React.useState(editWorld ? editWorld.artStyle : '');
      const [gameMechanics, setGameMechanics] = React.useState(editWorld ? editWorld.gameMechanics : '');
      const [winLossConditions, setWinLossConditions] = React.useState(editWorld ? editWorld.winLossConditions : '');
      const [isAutocompleting, setIsAutocompleting] = React.useState(false);

      async function handleAutoComplete() {
        setIsAutocompleting(true);
        const world = { name, description, genre, artStyle, gameMechanics, winLossConditions };
        try {
            const res = await fetch('/world/autocomplete', {
              method: 'POST',
              headers: {'Content-Type': 'application/json'},
              body: JSON.stringify({ world, ai_settings: aiSettings })
            });
            const data = await res.json();
            if (res.ok && data) {
                setName(data.name || name);
                setDescription(data.description || description);
                setGenre(data.genre || genre);
                setArtStyle(data.artStyle || artStyle);
                setGameMechanics(data.gameMechanics || gameMechanics);
                setWinLossConditions(data.winLossConditions || winLossConditions);
            } else {
                console.error("Autocomplete failed", data);
            }
        } catch (error) {
            console.error("Autocomplete request failed", error);
        } finally {
            setIsAutocompleting(false);
        }
      }

      return React.createElement('div', null,
        React.createElement('h2', null, editWorld ? 'Edit World' : 'Create New World'),
        React.createElement('div', null,
          React.createElement('label', null, 'Name: '),
          React.createElement('input', {
            value: name, onChange: e => setName(e.target.value),
            style: {width: '90%'}
          })
        ),
        React.createElement('div', null,
          React.createElement('label', null, 'Description: '),
          React.createElement('textarea', {
            value: description, onChange: e => setDescription(e.target.value),
            rows: 3, style: {width: '90%', fontFamily: 'inherit', fontSize: '1em'}
          }),
          React.createElement('button', {onClick: handleAutoComplete, style: {marginLeft: '1em'}, disabled: isAutocompleting}, isAutocompleting ? 'Loading...' : 'Auto-complete')
        ),
        React.createElement('details', null,
          React.createElement('summary', null, 'Advanced Options'),
          React.createElement('div', null,
            React.createElement('label', null, 'Genre: '),
            React.createElement('input', {
              value: genre, onChange: e => setGenre(e.target.value),
              style: {width: '90%'}
            })
          ),
          React.createElement('div', null,
            React.createElement('label', null, 'Art Style: '),
            React.createElement('input', {
              value: artStyle, onChange: e => setArtStyle(e.target.value),
              style: {width: '90%'}
            })
          ),
          React.createElement('div', null,
            React.createElement('label', null, 'Game Mechanics: '),
            React.createElement('textarea', {
              value: gameMechanics, onChange: e => setGameMechanics(e.target.value),
              rows: 3, style: {width: '90%', fontFamily: 'inherit', fontSize: '1em'}
            })
          ),
          React.createElement('div', null,
            React.createElement('label', null, 'Win/Loss Conditions: '),
            React.createElement('textarea', {
              value: winLossConditions, onChange: e => setWinLossConditions(e.target.value),
              rows: 3, style: {width: '90%', fontFamily: 'inherit', fontSize: '1em'}
            })
          )
        ),
        React.createElement('div', {style: {marginTop: '1em'}},
          React.createElement('button', {
            onClick: () => name && description && onSave({name, description, genre, artStyle, gameMechanics, winLossConditions}),
            style: {marginRight: '1em'}
          }, 'Save World'),
          React.createElement('button', {onClick: onCancel}, 'Cancel')
        )
      );
    }

    // Settings modal component
    function SettingsModal({worlds, editWorld, aiSettings, onClose, onEdit, onSave, onDelete, onAiSettingsChange}) {
      const [provider, setProvider] = React.useState(aiSettings.provider);
      const [apiKey, setApiKey] = React.useState(aiSettings.apiKey);

      function handleSaveAi() {
        onAiSettingsChange({ provider, apiKey });
        // Maybe close modal or give feedback
      }

      return React.createElement('div', {
        style: {
          position: 'fixed', top: 0, left: 0, width: '100vw', height: '100vh',
          background: '#0008', zIndex: 1000, display: 'flex', alignItems: 'center', justifyContent: 'center'
        }
      },
        React.createElement('div', {
          style: {
            background: '#fffbe6', borderRadius: '16px', padding: '2em', minWidth: '400px', boxShadow: '2px 2px 12px #0003'
          }
        },
          React.createElement('button', {onClick: onClose, style: {float: 'right'}}, 'Close'),
          React.createElement('h2', null, 'Settings'),

          React.createElement('h3', null, 'AI Configuration'),
          React.createElement('div', null,
            React.createElement('label', null, 'Provider: '),
            React.createElement('select', { value: provider, onChange: e => setProvider(e.target.value) },
              React.createElement('option', {value: 'openai'}, 'OpenAI'),
              React.createElement('option', {value: 'groq'}, 'Groq'),
              React.createElement('option', {value: 'openrouter'}, 'OpenRouter')
            )
          ),
          React.createElement('div', null,
            React.createElement('label', null, 'API Key: '),
            React.createElement('input', {
              type: 'password',
              value: apiKey, onChange: e => setApiKey(e.target.value),
              style: {width: '90%'}
            })
          ),
          React.createElement('div', {style: {marginTop: '1em'}},
             React.createElement('button', { onClick: handleSaveAi }, 'Save AI Settings')
          ),

          React.createElement('hr'),

          React.createElement('h3', null, 'All Worlds'),
          ...worlds.map(w => [
            React.createElement('div', {
              key: w.name,
              style: {margin: '0.5em 0', padding: '0.5em', background: '#f4e1b6', borderRadius: '8px'}
            },
              React.createElement('b', null, w.name),
              React.createElement('span', {style: {marginLeft: '1em'}}, w.description.slice(0, 40) + (w.description.length > 40 ? '...' : '')),
              React.createElement('button', {onClick: () => onEdit(w), style: {float: 'right'}}, 'Edit')
            )
          ])
        )
      );
    }

    ReactDOM.createRoot(document.getElementById('root')).render(React.createElement(App));
  </script>
</body>
</html>
